I started by writing the 1s and 0s parser as instructed, but after doing that I
decided I wanted my program to be able to reliably tokenize a given file before
doing any of the actual syntax.

The reason I chose to do it this way is that I knew my testing strategy for the
Syntax was most likely going to involve writing some .nal files and running them.

Which wouldn't have been possible without sorting out all of the file reading
infrastructure.
All of that code was easy to test function by function.

Then I started building the parser one command at a time, for each new command
I wrote a new .nal file which only tested that particular piece of syntax.
I also wrote a .nal file which was supposed to break at that particular syntax, and checked that when it terminated the program no leaks happened.

For example by having a .nal file which only contained a {, I noticed that the program was not terminating correctly.
And that was because, after completing an instruction I was simply increasing the current word index by 1.
But what happens if the current word is the last one?? Then when trying to read the next word, the program would be reading outside of the array!
To fix this I wrote the wordStep(int s) function, which increases the current word index by s, but also checks that the new index is withing the array, and returns an error if it is not.

When testing the ROT function, I first encountered some issues using the % operator, but it wasn't dealing properly with negative values so I used an if statement instead. Then when writing the arrays I used for testing lots of weird stuff kept happening until i realized I needed to add 1 to the size of each array for the end of string char.
